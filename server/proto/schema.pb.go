// Code generated by protoc-gen-go. DO NOT EDIT.
// source: schema.proto

/*
Package __schema is a generated protocol buffer package.

It is generated from these files:
	schema.proto

It has these top-level messages:
	Empty
	Packet
	FixedHeader
	Conn
	Connack
	Pingreq
	Pingresp
	Disconnect
	Publish
	Pubnew
	Pubreceive
	Pubreceipt
	Pubcomplete
	Subscription
	Subscribe
	Suback
	Unsubscribe
	Unsuback
*/
package __schema

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MessageType int32

const (
	MessageType_RERSERVED   MessageType = 0
	MessageType_CONNECT     MessageType = 1
	MessageType_CONNACK     MessageType = 2
	MessageType_PUBLISH     MessageType = 3
	MessageType_PUBNEW      MessageType = 4
	MessageType_PUBRECEIVE  MessageType = 5
	MessageType_PUBRECEIPT  MessageType = 6
	MessageType_PUBCOMPLETE MessageType = 7
	MessageType_SUBSCRIBE   MessageType = 8
	MessageType_SUBACK      MessageType = 9
	MessageType_UNSUBSCRIBE MessageType = 10
	MessageType_UNSUBACK    MessageType = 11
	MessageType_PINGREQ     MessageType = 12
	MessageType_PINGRESP    MessageType = 13
	MessageType_DISCONNECT  MessageType = 14
)

var MessageType_name = map[int32]string{
	0:  "RERSERVED",
	1:  "CONNECT",
	2:  "CONNACK",
	3:  "PUBLISH",
	4:  "PUBNEW",
	5:  "PUBRECEIVE",
	6:  "PUBRECEIPT",
	7:  "PUBCOMPLETE",
	8:  "SUBSCRIBE",
	9:  "SUBACK",
	10: "UNSUBSCRIBE",
	11: "UNSUBACK",
	12: "PINGREQ",
	13: "PINGRESP",
	14: "DISCONNECT",
}
var MessageType_value = map[string]int32{
	"RERSERVED":   0,
	"CONNECT":     1,
	"CONNACK":     2,
	"PUBLISH":     3,
	"PUBNEW":      4,
	"PUBRECEIVE":  5,
	"PUBRECEIPT":  6,
	"PUBCOMPLETE": 7,
	"SUBSCRIBE":   8,
	"SUBACK":      9,
	"UNSUBSCRIBE": 10,
	"UNSUBACK":    11,
	"PINGREQ":     12,
	"PINGRESP":    13,
	"DISCONNECT":  14,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (MessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Packet struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Packet) Reset()                    { *m = Packet{} }
func (m *Packet) String() string            { return proto.CompactTextString(m) }
func (*Packet) ProtoMessage()               {}
func (*Packet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Packet) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type FixedHeader struct {
	MessageType   MessageType `protobuf:"varint,1,opt,name=MessageType,enum=unitdb.schema.MessageType" json:"MessageType,omitempty"`
	MessageLength int32       `protobuf:"varint,2,opt,name=MessageLength" json:"MessageLength,omitempty"`
}

func (m *FixedHeader) Reset()                    { *m = FixedHeader{} }
func (m *FixedHeader) String() string            { return proto.CompactTextString(m) }
func (*FixedHeader) ProtoMessage()               {}
func (*FixedHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FixedHeader) GetMessageType() MessageType {
	if m != nil {
		return m.MessageType
	}
	return MessageType_RERSERVED
}

func (m *FixedHeader) GetMessageLength() int32 {
	if m != nil {
		return m.MessageLength
	}
	return 0
}

// Connect represents a connect Message.
type Conn struct {
	ProtoName     []byte `protobuf:"bytes,1,opt,name=ProtoName,proto3" json:"ProtoName,omitempty"`
	Version       int32  `protobuf:"varint,2,opt,name=Version" json:"Version,omitempty"`
	InsecureFlag  bool   `protobuf:"varint,3,opt,name=InsecureFlag" json:"InsecureFlag,omitempty"`
	CleanSessFlag bool   `protobuf:"varint,9,opt,name=CleanSessFlag" json:"CleanSessFlag,omitempty"`
	KeepAlive     int32  `protobuf:"varint,10,opt,name=KeepAlive" json:"KeepAlive,omitempty"`
	ClientID      []byte `protobuf:"bytes,11,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Username      []byte `protobuf:"bytes,14,opt,name=Username,proto3" json:"Username,omitempty"`
	Password      []byte `protobuf:"bytes,15,opt,name=Password,proto3" json:"Password,omitempty"`
}

func (m *Conn) Reset()                    { *m = Conn{} }
func (m *Conn) String() string            { return proto.CompactTextString(m) }
func (*Conn) ProtoMessage()               {}
func (*Conn) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Conn) GetProtoName() []byte {
	if m != nil {
		return m.ProtoName
	}
	return nil
}

func (m *Conn) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Conn) GetInsecureFlag() bool {
	if m != nil {
		return m.InsecureFlag
	}
	return false
}

func (m *Conn) GetCleanSessFlag() bool {
	if m != nil {
		return m.CleanSessFlag
	}
	return false
}

func (m *Conn) GetKeepAlive() int32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *Conn) GetClientID() []byte {
	if m != nil {
		return m.ClientID
	}
	return nil
}

func (m *Conn) GetUsername() []byte {
	if m != nil {
		return m.Username
	}
	return nil
}

func (m *Conn) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

// Connack represents a connack Message.
// 0x00 connection accepted
// 0x01 refused: unacceptable proto version
// 0x02 refused: identifier rejected
// 0x03 refused server unavailiable
// 0x04 bad user or password
// 0x05 not authorized
type Connack struct {
	ReturnCode int32 `protobuf:"varint,1,opt,name=ReturnCode" json:"ReturnCode,omitempty"`
	ConnID     int32 `protobuf:"varint,2,opt,name=ConnID" json:"ConnID,omitempty"`
}

func (m *Connack) Reset()                    { *m = Connack{} }
func (m *Connack) String() string            { return proto.CompactTextString(m) }
func (*Connack) ProtoMessage()               {}
func (*Connack) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Connack) GetReturnCode() int32 {
	if m != nil {
		return m.ReturnCode
	}
	return 0
}

func (m *Connack) GetConnID() int32 {
	if m != nil {
		return m.ConnID
	}
	return 0
}

// Pingreq is a keepalive
type Pingreq struct {
}

func (m *Pingreq) Reset()                    { *m = Pingreq{} }
func (m *Pingreq) String() string            { return proto.CompactTextString(m) }
func (*Pingreq) ProtoMessage()               {}
func (*Pingreq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// Pingresp is for saying "hey, the server is alive"
type Pingresp struct {
}

func (m *Pingresp) Reset()                    { *m = Pingresp{} }
func (m *Pingresp) String() string            { return proto.CompactTextString(m) }
func (*Pingresp) ProtoMessage()               {}
func (*Pingresp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// Disconnect is to signal you want to cease communications with the server
type Disconnect struct {
	MessageID int32 `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *Disconnect) Reset()                    { *m = Disconnect{} }
func (m *Disconnect) String() string            { return proto.CompactTextString(m) }
func (*Disconnect) ProtoMessage()               {}
func (*Disconnect) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Disconnect) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

// Publish represents a publish Message. It supports following delivery mode.
// 0 EXPRESS
// 1 RELIEABLE
// 2 BATCH
type Publish struct {
	MessageID    int32  `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
	DeliveryMode int32  `protobuf:"varint,2,opt,name=DeliveryMode" json:"DeliveryMode,omitempty"`
	Topic        []byte `protobuf:"bytes,3,opt,name=Topic,proto3" json:"Topic,omitempty"`
	Payload      []byte `protobuf:"bytes,4,opt,name=Payload,proto3" json:"Payload,omitempty"`
	Ttl          string `protobuf:"bytes,5,opt,name=Ttl" json:"Ttl,omitempty"`
}

func (m *Publish) Reset()                    { *m = Publish{} }
func (m *Publish) String() string            { return proto.CompactTextString(m) }
func (*Publish) ProtoMessage()               {}
func (*Publish) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Publish) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *Publish) GetDeliveryMode() int32 {
	if m != nil {
		return m.DeliveryMode
	}
	return 0
}

func (m *Publish) GetTopic() []byte {
	if m != nil {
		return m.Topic
	}
	return nil
}

func (m *Publish) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Publish) GetTtl() string {
	if m != nil {
		return m.Ttl
	}
	return ""
}

// Pubnew is tells subscriber a PUBLISH Message is available.
type Pubnew struct {
	MessageID int32 `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *Pubnew) Reset()                    { *m = Pubnew{} }
func (m *Pubnew) String() string            { return proto.CompactTextString(m) }
func (*Pubnew) ProtoMessage()               {}
func (*Pubnew) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Pubnew) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

// Pubreceive is a publish receive request to the server in response to PUBNEW Message to start receiving the published message.
type Pubreceive struct {
	MessageID int32 `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *Pubreceive) Reset()                    { *m = Pubreceive{} }
func (m *Pubreceive) String() string            { return proto.CompactTextString(m) }
func (*Pubreceive) ProtoMessage()               {}
func (*Pubreceive) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Pubreceive) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

// Pubreceipt is for verifying the receipt of a publish
// A PUBRECEIPT Message is sent by the server in response to a PUBLISH Message from a publishing client, or by a subscriber in response to a PUBLISH Message from the server."
type Pubreceipt struct {
	MessageID int32 `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *Pubreceipt) Reset()                    { *m = Pubreceipt{} }
func (m *Pubreceipt) String() string            { return proto.CompactTextString(m) }
func (*Pubreceipt) ProtoMessage()               {}
func (*Pubreceipt) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Pubreceipt) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

// Pubcomplete is for saying is in response to a Pubreceipt sent by the publisher
type Pubcomplete struct {
	MessageID int32 `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *Pubcomplete) Reset()                    { *m = Pubcomplete{} }
func (m *Pubcomplete) String() string            { return proto.CompactTextString(m) }
func (*Pubcomplete) ProtoMessage()               {}
func (*Pubcomplete) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Pubcomplete) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

// Subscription is pairing the delivery mode and topic together
// for the delivery mode's pairs in unsubscribe and subscribe
// 0 EXPRESS
// 1 RELIEABLE
// 2 BATCH
type Subscription struct {
	DeliveryMode int32  `protobuf:"varint,1,opt,name=DeliveryMode" json:"DeliveryMode,omitempty"`
	Topic        []byte `protobuf:"bytes,2,opt,name=Topic,proto3" json:"Topic,omitempty"`
	Last         string `protobuf:"bytes,3,opt,name=Last" json:"Last,omitempty"`
}

func (m *Subscription) Reset()                    { *m = Subscription{} }
func (m *Subscription) String() string            { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()               {}
func (*Subscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Subscription) GetDeliveryMode() int32 {
	if m != nil {
		return m.DeliveryMode
	}
	return 0
}

func (m *Subscription) GetTopic() []byte {
	if m != nil {
		return m.Topic
	}
	return nil
}

func (m *Subscription) GetLast() string {
	if m != nil {
		return m.Last
	}
	return ""
}

// Subscribe tells the server which topics the client would like to subscribe to and choose a delivery mode.
type Subscribe struct {
	MessageID     int32           `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
	Subscriptions []*Subscription `protobuf:"bytes,2,rep,name=Subscriptions" json:"Subscriptions,omitempty"`
}

func (m *Subscribe) Reset()                    { *m = Subscribe{} }
func (m *Subscribe) String() string            { return proto.CompactTextString(m) }
func (*Subscribe) ProtoMessage()               {}
func (*Subscribe) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Subscribe) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *Subscribe) GetSubscriptions() []*Subscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

// Suback is to say "hey, you got it buddy. I will send you messages that fit this pattern"
type Suback struct {
	MessageID int32 `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *Suback) Reset()                    { *m = Suback{} }
func (m *Suback) String() string            { return proto.CompactTextString(m) }
func (*Suback) ProtoMessage()               {}
func (*Suback) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Suback) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

// Unsubscribe is the Message to send if you don't want to subscribe to a topic anymore
type Unsubscribe struct {
	MessageID     int32           `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
	Subscriptions []*Subscription `protobuf:"bytes,2,rep,name=Subscriptions" json:"Subscriptions,omitempty"`
}

func (m *Unsubscribe) Reset()                    { *m = Unsubscribe{} }
func (m *Unsubscribe) String() string            { return proto.CompactTextString(m) }
func (*Unsubscribe) ProtoMessage()               {}
func (*Unsubscribe) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Unsubscribe) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *Unsubscribe) GetSubscriptions() []*Subscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

// Unsuback is to unsubscribe as suback is to subscribe
type Unsuback struct {
	MessageID int32 `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *Unsuback) Reset()                    { *m = Unsuback{} }
func (m *Unsuback) String() string            { return proto.CompactTextString(m) }
func (*Unsuback) ProtoMessage()               {}
func (*Unsuback) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Unsuback) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func init() {
	proto.RegisterType((*Empty)(nil), "unitdb.schema.Empty")
	proto.RegisterType((*Packet)(nil), "unitdb.schema.Packet")
	proto.RegisterType((*FixedHeader)(nil), "unitdb.schema.FixedHeader")
	proto.RegisterType((*Conn)(nil), "unitdb.schema.Conn")
	proto.RegisterType((*Connack)(nil), "unitdb.schema.Connack")
	proto.RegisterType((*Pingreq)(nil), "unitdb.schema.Pingreq")
	proto.RegisterType((*Pingresp)(nil), "unitdb.schema.Pingresp")
	proto.RegisterType((*Disconnect)(nil), "unitdb.schema.Disconnect")
	proto.RegisterType((*Publish)(nil), "unitdb.schema.Publish")
	proto.RegisterType((*Pubnew)(nil), "unitdb.schema.Pubnew")
	proto.RegisterType((*Pubreceive)(nil), "unitdb.schema.Pubreceive")
	proto.RegisterType((*Pubreceipt)(nil), "unitdb.schema.Pubreceipt")
	proto.RegisterType((*Pubcomplete)(nil), "unitdb.schema.Pubcomplete")
	proto.RegisterType((*Subscription)(nil), "unitdb.schema.Subscription")
	proto.RegisterType((*Subscribe)(nil), "unitdb.schema.Subscribe")
	proto.RegisterType((*Suback)(nil), "unitdb.schema.Suback")
	proto.RegisterType((*Unsubscribe)(nil), "unitdb.schema.Unsubscribe")
	proto.RegisterType((*Unsuback)(nil), "unitdb.schema.Unsuback")
	proto.RegisterEnum("unitdb.schema.MessageType", MessageType_name, MessageType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Unitdb service

type UnitdbClient interface {
	Stream(ctx context.Context, opts ...grpc.CallOption) (Unitdb_StreamClient, error)
}

type unitdbClient struct {
	cc *grpc.ClientConn
}

func NewUnitdbClient(cc *grpc.ClientConn) UnitdbClient {
	return &unitdbClient{cc}
}

func (c *unitdbClient) Stream(ctx context.Context, opts ...grpc.CallOption) (Unitdb_StreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Unitdb_serviceDesc.Streams[0], c.cc, "/unitdb.schema.Unitdb/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &unitdbStreamClient{stream}
	return x, nil
}

type Unitdb_StreamClient interface {
	Send(*Packet) error
	Recv() (*Packet, error)
	grpc.ClientStream
}

type unitdbStreamClient struct {
	grpc.ClientStream
}

func (x *unitdbStreamClient) Send(m *Packet) error {
	return x.ClientStream.SendMsg(m)
}

func (x *unitdbStreamClient) Recv() (*Packet, error) {
	m := new(Packet)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Unitdb service

type UnitdbServer interface {
	Stream(Unitdb_StreamServer) error
}

func RegisterUnitdbServer(s *grpc.Server, srv UnitdbServer) {
	s.RegisterService(&_Unitdb_serviceDesc, srv)
}

func _Unitdb_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UnitdbServer).Stream(&unitdbStreamServer{stream})
}

type Unitdb_StreamServer interface {
	Send(*Packet) error
	Recv() (*Packet, error)
	grpc.ServerStream
}

type unitdbStreamServer struct {
	grpc.ServerStream
}

func (x *unitdbStreamServer) Send(m *Packet) error {
	return x.ServerStream.SendMsg(m)
}

func (x *unitdbStreamServer) Recv() (*Packet, error) {
	m := new(Packet)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Unitdb_serviceDesc = grpc.ServiceDesc{
	ServiceName: "unitdb.schema.Unitdb",
	HandlerType: (*UnitdbServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _Unitdb_Stream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "schema.proto",
}

func init() { proto.RegisterFile("schema.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 721 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xcd, 0x6e, 0xf3, 0x44,
	0x14, 0xc5, 0xf9, 0x71, 0xe2, 0xeb, 0x24, 0x9f, 0x35, 0x02, 0x64, 0x95, 0x0a, 0x45, 0x16, 0x42,
	0x51, 0x91, 0x22, 0x54, 0x76, 0xc0, 0x26, 0xfe, 0x29, 0xb5, 0x9a, 0xa6, 0xc3, 0x38, 0x2e, 0x12,
	0x62, 0x63, 0x3b, 0xa3, 0xd4, 0xaa, 0x33, 0x76, 0x3d, 0x36, 0x25, 0x0f, 0xc1, 0x63, 0xf2, 0x12,
	0xac, 0xd0, 0xd8, 0x0e, 0x89, 0x2b, 0xd4, 0xb0, 0xfa, 0x76, 0x73, 0xce, 0x3d, 0xb9, 0xf7, 0xdc,
	0x33, 0x8e, 0x0d, 0x23, 0x1e, 0x3d, 0xd1, 0x5d, 0x30, 0xcf, 0xf2, 0xb4, 0x48, 0xd1, 0xb8, 0x64,
	0x71, 0xb1, 0x09, 0xe7, 0x35, 0x69, 0x0c, 0xa0, 0xef, 0xec, 0xb2, 0x62, 0x6f, 0x5c, 0x82, 0x8c,
	0x83, 0xe8, 0x99, 0x16, 0x08, 0x41, 0x6f, 0x13, 0x14, 0x81, 0x2e, 0x4d, 0xa5, 0xd9, 0x88, 0x54,
	0x67, 0xe3, 0x05, 0xd4, 0x9b, 0xf8, 0x0f, 0xba, 0xb9, 0xa5, 0xc1, 0x86, 0xe6, 0xe8, 0x47, 0x50,
	0xef, 0x29, 0xe7, 0xc1, 0x96, 0xae, 0xf7, 0x19, 0xad, 0x94, 0x93, 0xeb, 0x8b, 0x79, 0xab, 0xf5,
	0xfc, 0x44, 0x41, 0x4e, 0xe5, 0xe8, 0x2b, 0x18, 0x37, 0x70, 0x49, 0xd9, 0xb6, 0x78, 0xd2, 0x3b,
	0x53, 0x69, 0xd6, 0x27, 0x6d, 0xd2, 0xf8, 0x5b, 0x82, 0x9e, 0x95, 0x32, 0x86, 0x2e, 0x41, 0xc1,
	0xc2, 0xfa, 0x2a, 0xd8, 0xd1, 0xc6, 0xd4, 0x91, 0x40, 0x3a, 0x0c, 0x1e, 0x69, 0xce, 0xe3, 0x94,
	0x35, 0x6d, 0x0e, 0x10, 0x19, 0x30, 0x72, 0x19, 0xa7, 0x51, 0x99, 0xd3, 0x9b, 0x24, 0xd8, 0xea,
	0xdd, 0xa9, 0x34, 0x1b, 0x92, 0x16, 0x27, 0xac, 0x58, 0x09, 0x0d, 0x98, 0x47, 0x39, 0xaf, 0x44,
	0x4a, 0x25, 0x6a, 0x93, 0xc2, 0xc1, 0x1d, 0xa5, 0xd9, 0x22, 0x89, 0x7f, 0xa7, 0x3a, 0x54, 0x53,
	0x8e, 0x04, 0xba, 0x80, 0xa1, 0x95, 0xc4, 0x94, 0x15, 0xae, 0xad, 0xab, 0x95, 0xbd, 0x7f, 0xb1,
	0xa8, 0xf9, 0x9c, 0xe6, 0x4c, 0x58, 0x9f, 0xd4, 0xb5, 0x03, 0x16, 0x35, 0x1c, 0x70, 0xfe, 0x9a,
	0xe6, 0x1b, 0xfd, 0x43, 0x5d, 0x3b, 0x60, 0x63, 0x01, 0x03, 0xb1, 0x7b, 0x10, 0x3d, 0xa3, 0x2f,
	0x01, 0x08, 0x2d, 0xca, 0x9c, 0x59, 0xe9, 0xa6, 0xde, 0xbf, 0x4f, 0x4e, 0x18, 0xf4, 0x39, 0xc8,
	0x42, 0xea, 0xda, 0xcd, 0xfe, 0x0d, 0x32, 0x14, 0x18, 0xe0, 0x98, 0x6d, 0x73, 0xfa, 0x62, 0x00,
	0x0c, 0xeb, 0x23, 0xcf, 0x8c, 0x2b, 0x00, 0x3b, 0xe6, 0x51, 0xca, 0x18, 0x8d, 0x0a, 0xb1, 0x59,
	0x93, 0xba, 0x6b, 0x37, 0xbd, 0x8f, 0x84, 0xf1, 0xa7, 0x04, 0x03, 0x5c, 0x86, 0x49, 0xcc, 0x9f,
	0xde, 0x57, 0x8a, 0xac, 0x6d, 0x2a, 0xd2, 0xc8, 0xf7, 0xf7, 0xc2, 0x66, 0x6d, 0xa5, 0xc5, 0xa1,
	0x4f, 0xa1, 0xbf, 0x4e, 0xb3, 0x38, 0xaa, 0x2e, 0x62, 0x44, 0x6a, 0x20, 0xee, 0x0f, 0x07, 0xfb,
	0x24, 0x0d, 0x36, 0x7a, 0xaf, 0xe2, 0x0f, 0x10, 0x69, 0xd0, 0x5d, 0x17, 0x89, 0xde, 0x9f, 0x4a,
	0x33, 0x85, 0x88, 0xa3, 0xf1, 0x35, 0xc8, 0xb8, 0x0c, 0x19, 0x7d, 0x3d, 0xe3, 0xfb, 0x0a, 0x00,
	0x97, 0x61, 0x4e, 0x23, 0x2a, 0xee, 0xe7, 0x7f, 0x6b, 0xb3, 0x73, 0x79, 0x7c, 0x03, 0x2a, 0x2e,
	0xc3, 0x28, 0xdd, 0x65, 0x09, 0x2d, 0xce, 0x35, 0xfe, 0x0d, 0x46, 0x5e, 0x19, 0xf2, 0x28, 0x8f,
	0xb3, 0xa2, 0x79, 0x1c, 0x5b, 0x11, 0x49, 0xef, 0x45, 0xd4, 0x39, 0x8d, 0x08, 0x41, 0x6f, 0x19,
	0xf0, 0xa2, 0xca, 0x4d, 0x21, 0xd5, 0xd9, 0x48, 0x40, 0x69, 0xba, 0x87, 0x67, 0x8c, 0xa0, 0x05,
	0x8c, 0x4f, 0x8d, 0x70, 0xbd, 0x33, 0xed, 0xce, 0xd4, 0xeb, 0x2f, 0xde, 0xfc, 0x5d, 0x4f, 0x35,
	0xa4, 0xfd, 0x0b, 0x11, 0xbc, 0x57, 0x86, 0xe2, 0x69, 0x7c, 0x7f, 0x67, 0x06, 0xaa, 0xcf, 0xf8,
	0xc7, 0xf3, 0x35, 0x83, 0x61, 0x35, 0xef, 0xac, 0xb3, 0xab, 0xbf, 0xa4, 0xd6, 0x2b, 0x0b, 0x8d,
	0x41, 0x21, 0x0e, 0xf1, 0x1c, 0xf2, 0xe8, 0xd8, 0xda, 0x27, 0x48, 0x85, 0x81, 0xf5, 0xb0, 0x5a,
	0x39, 0xd6, 0x5a, 0x93, 0x0e, 0x60, 0x61, 0xdd, 0x69, 0x1d, 0x01, 0xb0, 0x6f, 0x2e, 0x5d, 0xef,
	0x56, 0xeb, 0x22, 0x00, 0x19, 0xfb, 0xe6, 0xca, 0xf9, 0x45, 0xeb, 0xa1, 0x09, 0x00, 0xf6, 0x4d,
	0xe2, 0x58, 0x8e, 0xfb, 0xe8, 0x68, 0xfd, 0x53, 0x8c, 0xd7, 0x9a, 0x8c, 0x3e, 0x80, 0x8a, 0x7d,
	0xd3, 0x7a, 0xb8, 0xc7, 0x4b, 0x67, 0xed, 0x68, 0x03, 0x31, 0xd2, 0xf3, 0x4d, 0xcf, 0x22, 0xae,
	0xe9, 0x68, 0x43, 0xd1, 0xcb, 0xf3, 0x4d, 0x31, 0x44, 0x11, 0x5a, 0x7f, 0x75, 0x2c, 0x02, 0x1a,
	0xc1, 0xb0, 0x22, 0x44, 0x59, 0xad, 0x3c, 0xb8, 0xab, 0x9f, 0x88, 0xf3, 0xb3, 0x36, 0x12, 0xa5,
	0x1a, 0x78, 0x58, 0x1b, 0x8b, 0xa9, 0xb6, 0xeb, 0x1d, 0xbc, 0x4f, 0xae, 0x6d, 0x90, 0xfd, 0x2a,
	0x3e, 0xf4, 0x3d, 0xc8, 0x5e, 0x91, 0xd3, 0x60, 0x87, 0x3e, 0x7b, 0x93, 0x68, 0xfd, 0x9e, 0xbf,
	0xf8, 0x6f, 0x7a, 0x26, 0x7d, 0x2b, 0x99, 0xf0, 0xeb, 0x70, 0xfe, 0x43, 0x4d, 0x87, 0x72, 0xf5,
	0xdd, 0xf8, 0xee, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x13, 0x14, 0x0f, 0x5d, 0x47, 0x06, 0x00,
	0x00,
}
