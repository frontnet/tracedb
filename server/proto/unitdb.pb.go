// Code generated by protoc-gen-go. DO NOT EDIT.
// source: unitdb.proto

/*
Package __schema is a generated protocol buffer package.

It is generated from these files:
	unitdb.proto

It has these top-level messages:
	Empty
	Packet
	FixedHeader
	Connect
	ConnectAcknowledge
	PingRequest
	Disconnect
	PublishMessage
	Publish
	RelayRequest
	Relay
	Subscription
	Subscribe
	Unsubscribe
	ControlMessage
*/
package __schema

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FlowControl int32

const (
	FlowControl_NONE        FlowControl = 0
	FlowControl_ACKNOWLEDGE FlowControl = 1
	FlowControl_NOTIFY      FlowControl = 2
	FlowControl_RECEIVE     FlowControl = 3
	FlowControl_RECEIPT     FlowControl = 4
	FlowControl_COMPLETE    FlowControl = 5
)

var FlowControl_name = map[int32]string{
	0: "NONE",
	1: "ACKNOWLEDGE",
	2: "NOTIFY",
	3: "RECEIVE",
	4: "RECEIPT",
	5: "COMPLETE",
}
var FlowControl_value = map[string]int32{
	"NONE":        0,
	"ACKNOWLEDGE": 1,
	"NOTIFY":      2,
	"RECEIVE":     3,
	"RECEIPT":     4,
	"COMPLETE":    5,
}

func (x FlowControl) String() string {
	return proto.EnumName(FlowControl_name, int32(x))
}
func (FlowControl) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type MessageType int32

const (
	MessageType_RERSERVED   MessageType = 0
	MessageType_CONNECT     MessageType = 1
	MessageType_PUBLISH     MessageType = 2
	MessageType_RELAY       MessageType = 3
	MessageType_SUBSCRIBE   MessageType = 4
	MessageType_UNSUBSCRIBE MessageType = 5
	MessageType_PINGREQ     MessageType = 6
	MessageType_DISCONNECT  MessageType = 7
)

var MessageType_name = map[int32]string{
	0: "RERSERVED",
	1: "CONNECT",
	2: "PUBLISH",
	3: "RELAY",
	4: "SUBSCRIBE",
	5: "UNSUBSCRIBE",
	6: "PINGREQ",
	7: "DISCONNECT",
}
var MessageType_value = map[string]int32{
	"RERSERVED":   0,
	"CONNECT":     1,
	"PUBLISH":     2,
	"RELAY":       3,
	"SUBSCRIBE":   4,
	"UNSUBSCRIBE": 5,
	"PINGREQ":     6,
	"DISCONNECT":  7,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (MessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Packet struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Packet) Reset()                    { *m = Packet{} }
func (m *Packet) String() string            { return proto.CompactTextString(m) }
func (*Packet) ProtoMessage()               {}
func (*Packet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Packet) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type FixedHeader struct {
	MessageType   MessageType `protobuf:"varint,1,opt,name=MessageType,enum=unitdb.schema.MessageType" json:"MessageType,omitempty"`
	FlowControl   FlowControl `protobuf:"varint,2,opt,name=FlowControl,enum=unitdb.schema.FlowControl" json:"FlowControl,omitempty"`
	MessageLength int32       `protobuf:"varint,3,opt,name=MessageLength" json:"MessageLength,omitempty"`
}

func (m *FixedHeader) Reset()                    { *m = FixedHeader{} }
func (m *FixedHeader) String() string            { return proto.CompactTextString(m) }
func (*FixedHeader) ProtoMessage()               {}
func (*FixedHeader) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FixedHeader) GetMessageType() MessageType {
	if m != nil {
		return m.MessageType
	}
	return MessageType_RERSERVED
}

func (m *FixedHeader) GetFlowControl() FlowControl {
	if m != nil {
		return m.FlowControl
	}
	return FlowControl_NONE
}

func (m *FixedHeader) GetMessageLength() int32 {
	if m != nil {
		return m.MessageLength
	}
	return 0
}

// Connect represents a CONNECT Message type.
type Connect struct {
	Version             int32  `protobuf:"varint,1,opt,name=Version" json:"Version,omitempty"`
	InsecureFlag        bool   `protobuf:"varint,2,opt,name=InsecureFlag" json:"InsecureFlag,omitempty"`
	ClientID            string `protobuf:"bytes,3,opt,name=ClientID" json:"ClientID,omitempty"`
	KeepAlive           int32  `protobuf:"varint,4,opt,name=KeepAlive" json:"KeepAlive,omitempty"`
	CleanSessFlag       bool   `protobuf:"varint,5,opt,name=CleanSessFlag" json:"CleanSessFlag,omitempty"`
	SessKey             int32  `protobuf:"varint,6,opt,name=SessKey" json:"SessKey,omitempty"`
	Username            string `protobuf:"bytes,7,opt,name=Username" json:"Username,omitempty"`
	Password            []byte `protobuf:"bytes,8,opt,name=Password,proto3" json:"Password,omitempty"`
	BatchDuration       int32  `protobuf:"varint,9,opt,name=BatchDuration" json:"BatchDuration,omitempty"`
	BatchByteThreshold  int32  `protobuf:"varint,10,opt,name=BatchByteThreshold" json:"BatchByteThreshold,omitempty"`
	BatchCountThreshold int32  `protobuf:"varint,11,opt,name=BatchCountThreshold" json:"BatchCountThreshold,omitempty"`
}

func (m *Connect) Reset()                    { *m = Connect{} }
func (m *Connect) String() string            { return proto.CompactTextString(m) }
func (*Connect) ProtoMessage()               {}
func (*Connect) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Connect) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Connect) GetInsecureFlag() bool {
	if m != nil {
		return m.InsecureFlag
	}
	return false
}

func (m *Connect) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Connect) GetKeepAlive() int32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *Connect) GetCleanSessFlag() bool {
	if m != nil {
		return m.CleanSessFlag
	}
	return false
}

func (m *Connect) GetSessKey() int32 {
	if m != nil {
		return m.SessKey
	}
	return 0
}

func (m *Connect) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Connect) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *Connect) GetBatchDuration() int32 {
	if m != nil {
		return m.BatchDuration
	}
	return 0
}

func (m *Connect) GetBatchByteThreshold() int32 {
	if m != nil {
		return m.BatchByteThreshold
	}
	return 0
}

func (m *Connect) GetBatchCountThreshold() int32 {
	if m != nil {
		return m.BatchCountThreshold
	}
	return 0
}

// ConnectAcknowledge represents a CONNECT Acknowledge Message type.
// 0x00 connection accepted
// 0x01 refused: unacceptable proto version
// 0x02 refused: identifier rejected
// 0x03 refused: unacceptable identifier, access not allowed
// 0x04 refused server unavailiable
// 0x05 not authorized
// 0x06 bad request
type ConnectAcknowledge struct {
	ReturnCode int32 `protobuf:"varint,1,opt,name=ReturnCode" json:"ReturnCode,omitempty"`
	Epoch      int32 `protobuf:"varint,2,opt,name=Epoch" json:"Epoch,omitempty"`
	ConnID     int32 `protobuf:"varint,3,opt,name=ConnID" json:"ConnID,omitempty"`
}

func (m *ConnectAcknowledge) Reset()                    { *m = ConnectAcknowledge{} }
func (m *ConnectAcknowledge) String() string            { return proto.CompactTextString(m) }
func (*ConnectAcknowledge) ProtoMessage()               {}
func (*ConnectAcknowledge) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ConnectAcknowledge) GetReturnCode() int32 {
	if m != nil {
		return m.ReturnCode
	}
	return 0
}

func (m *ConnectAcknowledge) GetEpoch() int32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ConnectAcknowledge) GetConnID() int32 {
	if m != nil {
		return m.ConnID
	}
	return 0
}

// PingRequest is a keepalive
type PingRequest struct {
}

func (m *PingRequest) Reset()                    { *m = PingRequest{} }
func (m *PingRequest) String() string            { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()               {}
func (*PingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// Disconnect is to signal client want to cease communications with the server.
type Disconnect struct {
	MessageID int32 `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
}

func (m *Disconnect) Reset()                    { *m = Disconnect{} }
func (m *Disconnect) String() string            { return proto.CompactTextString(m) }
func (*Disconnect) ProtoMessage()               {}
func (*Disconnect) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Disconnect) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

type PublishMessage struct {
	Topic   string `protobuf:"bytes,1,opt,name=Topic" json:"Topic,omitempty"`
	Payload []byte `protobuf:"bytes,2,opt,name=Payload,proto3" json:"Payload,omitempty"`
	Ttl     string `protobuf:"bytes,3,opt,name=Ttl" json:"Ttl,omitempty"`
}

func (m *PublishMessage) Reset()                    { *m = PublishMessage{} }
func (m *PublishMessage) String() string            { return proto.CompactTextString(m) }
func (*PublishMessage) ProtoMessage()               {}
func (*PublishMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PublishMessage) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *PublishMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *PublishMessage) GetTtl() string {
	if m != nil {
		return m.Ttl
	}
	return ""
}

// Publish represents a PUBREQ Message type. It supports following delivery mode.
// 0 EXPRESS
// 1 RELIEABLE
// 2 BATCH
type Publish struct {
	MessageID    int32             `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
	DeliveryMode int32             `protobuf:"varint,2,opt,name=DeliveryMode" json:"DeliveryMode,omitempty"`
	Messages     []*PublishMessage `protobuf:"bytes,3,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *Publish) Reset()                    { *m = Publish{} }
func (m *Publish) String() string            { return proto.CompactTextString(m) }
func (*Publish) ProtoMessage()               {}
func (*Publish) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Publish) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *Publish) GetDeliveryMode() int32 {
	if m != nil {
		return m.DeliveryMode
	}
	return 0
}

func (m *Publish) GetMessages() []*PublishMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

// RelayRequest is pairing the Topic and Last parameter together
type RelayRequest struct {
	Topic string `protobuf:"bytes,1,opt,name=Topic" json:"Topic,omitempty"`
	Last  string `protobuf:"bytes,2,opt,name=Last" json:"Last,omitempty"`
}

func (m *RelayRequest) Reset()                    { *m = RelayRequest{} }
func (m *RelayRequest) String() string            { return proto.CompactTextString(m) }
func (*RelayRequest) ProtoMessage()               {}
func (*RelayRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RelayRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *RelayRequest) GetLast() string {
	if m != nil {
		return m.Last
	}
	return ""
}

// Relay tells the server which topics and last durations the client would like get data. The Delivery Mode for relay is EXPRESS.
type Relay struct {
	MessageID     int32           `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
	RelayRequests []*RelayRequest `protobuf:"bytes,2,rep,name=relayRequests" json:"relayRequests,omitempty"`
}

func (m *Relay) Reset()                    { *m = Relay{} }
func (m *Relay) String() string            { return proto.CompactTextString(m) }
func (*Relay) ProtoMessage()               {}
func (*Relay) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Relay) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *Relay) GetRelayRequests() []*RelayRequest {
	if m != nil {
		return m.RelayRequests
	}
	return nil
}

// Subscription is pairing the Delivery Mode and Topic together
// for the delivery mode's pairs in unsubscribe and subscribe.
// Delay in Millisecond to delay the messsage delivery if DeliveryMode is RELIEABLE or BATCH.
// 0 EXPRESS
// 1 RELIEABLE
// 2 BATCH
type Subscription struct {
	DeliveryMode int32  `protobuf:"varint,1,opt,name=DeliveryMode" json:"DeliveryMode,omitempty"`
	Delay        int32  `protobuf:"varint,2,opt,name=Delay" json:"Delay,omitempty"`
	Topic        string `protobuf:"bytes,3,opt,name=Topic" json:"Topic,omitempty"`
}

func (m *Subscription) Reset()                    { *m = Subscription{} }
func (m *Subscription) String() string            { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()               {}
func (*Subscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Subscription) GetDeliveryMode() int32 {
	if m != nil {
		return m.DeliveryMode
	}
	return 0
}

func (m *Subscription) GetDelay() int32 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *Subscription) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

// Subscribe tells the server which topics the client would like to subscribe to and choose a Delivery Mode.
type Subscribe struct {
	MessageID     int32           `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
	Subscriptions []*Subscription `protobuf:"bytes,2,rep,name=Subscriptions" json:"Subscriptions,omitempty"`
}

func (m *Subscribe) Reset()                    { *m = Subscribe{} }
func (m *Subscribe) String() string            { return proto.CompactTextString(m) }
func (*Subscribe) ProtoMessage()               {}
func (*Subscribe) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Subscribe) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *Subscribe) GetSubscriptions() []*Subscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

// Unsubscribe is the Message to send if you don't want to subscribe to a topic anymore.
type Unsubscribe struct {
	MessageID     int32           `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
	Subscriptions []*Subscription `protobuf:"bytes,2,rep,name=Subscriptions" json:"Subscriptions,omitempty"`
}

func (m *Unsubscribe) Reset()                    { *m = Unsubscribe{} }
func (m *Unsubscribe) String() string            { return proto.CompactTextString(m) }
func (*Unsubscribe) ProtoMessage()               {}
func (*Unsubscribe) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Unsubscribe) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *Unsubscribe) GetSubscriptions() []*Subscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

// ControlMessage is a Flow Control Message.
type ControlMessage struct {
	MessageID int32 `protobuf:"varint,1,opt,name=MessageID" json:"MessageID,omitempty"`
	// Optional Control Message bytes
	Message []byte `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *ControlMessage) Reset()                    { *m = ControlMessage{} }
func (m *ControlMessage) String() string            { return proto.CompactTextString(m) }
func (*ControlMessage) ProtoMessage()               {}
func (*ControlMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ControlMessage) GetMessageID() int32 {
	if m != nil {
		return m.MessageID
	}
	return 0
}

func (m *ControlMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "unitdb.schema.Empty")
	proto.RegisterType((*Packet)(nil), "unitdb.schema.Packet")
	proto.RegisterType((*FixedHeader)(nil), "unitdb.schema.FixedHeader")
	proto.RegisterType((*Connect)(nil), "unitdb.schema.Connect")
	proto.RegisterType((*ConnectAcknowledge)(nil), "unitdb.schema.ConnectAcknowledge")
	proto.RegisterType((*PingRequest)(nil), "unitdb.schema.PingRequest")
	proto.RegisterType((*Disconnect)(nil), "unitdb.schema.Disconnect")
	proto.RegisterType((*PublishMessage)(nil), "unitdb.schema.PublishMessage")
	proto.RegisterType((*Publish)(nil), "unitdb.schema.Publish")
	proto.RegisterType((*RelayRequest)(nil), "unitdb.schema.RelayRequest")
	proto.RegisterType((*Relay)(nil), "unitdb.schema.Relay")
	proto.RegisterType((*Subscription)(nil), "unitdb.schema.Subscription")
	proto.RegisterType((*Subscribe)(nil), "unitdb.schema.Subscribe")
	proto.RegisterType((*Unsubscribe)(nil), "unitdb.schema.Unsubscribe")
	proto.RegisterType((*ControlMessage)(nil), "unitdb.schema.ControlMessage")
	proto.RegisterEnum("unitdb.schema.FlowControl", FlowControl_name, FlowControl_value)
	proto.RegisterEnum("unitdb.schema.MessageType", MessageType_name, MessageType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Unitdb service

type UnitdbClient interface {
	Stream(ctx context.Context, opts ...grpc.CallOption) (Unitdb_StreamClient, error)
}

type unitdbClient struct {
	cc *grpc.ClientConn
}

func NewUnitdbClient(cc *grpc.ClientConn) UnitdbClient {
	return &unitdbClient{cc}
}

func (c *unitdbClient) Stream(ctx context.Context, opts ...grpc.CallOption) (Unitdb_StreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Unitdb_serviceDesc.Streams[0], c.cc, "/unitdb.schema.Unitdb/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &unitdbStreamClient{stream}
	return x, nil
}

type Unitdb_StreamClient interface {
	Send(*Packet) error
	Recv() (*Packet, error)
	grpc.ClientStream
}

type unitdbStreamClient struct {
	grpc.ClientStream
}

func (x *unitdbStreamClient) Send(m *Packet) error {
	return x.ClientStream.SendMsg(m)
}

func (x *unitdbStreamClient) Recv() (*Packet, error) {
	m := new(Packet)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Unitdb service

type UnitdbServer interface {
	Stream(Unitdb_StreamServer) error
}

func RegisterUnitdbServer(s *grpc.Server, srv UnitdbServer) {
	s.RegisterService(&_Unitdb_serviceDesc, srv)
}

func _Unitdb_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UnitdbServer).Stream(&unitdbStreamServer{stream})
}

type Unitdb_StreamServer interface {
	Send(*Packet) error
	Recv() (*Packet, error)
	grpc.ServerStream
}

type unitdbStreamServer struct {
	grpc.ServerStream
}

func (x *unitdbStreamServer) Send(m *Packet) error {
	return x.ServerStream.SendMsg(m)
}

func (x *unitdbStreamServer) Recv() (*Packet, error) {
	m := new(Packet)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Unitdb_serviceDesc = grpc.ServiceDesc{
	ServiceName: "unitdb.schema.Unitdb",
	HandlerType: (*UnitdbServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _Unitdb_Stream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "unitdb.proto",
}

func init() { proto.RegisterFile("unitdb.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 839 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0x4d, 0x6f, 0xe2, 0x46,
	0x18, 0x5e, 0x07, 0x0c, 0xf8, 0x05, 0x52, 0x6b, 0xba, 0xad, 0xac, 0x6d, 0x5a, 0x45, 0x56, 0x0f,
	0x51, 0x0e, 0x68, 0x95, 0x5e, 0xfa, 0x75, 0x01, 0xdb, 0xd9, 0x58, 0x21, 0x40, 0x07, 0x48, 0xb5,
	0x55, 0x55, 0x69, 0xb0, 0x5f, 0x81, 0xb5, 0x8e, 0x4d, 0x3d, 0x43, 0x53, 0x2e, 0x95, 0x7a, 0xe9,
	0xdf, 0xe9, 0x5f, 0xac, 0x66, 0x18, 0x82, 0x1d, 0xb1, 0xbb, 0xb7, 0xde, 0xe6, 0x79, 0xfc, 0x7e,
	0x3c, 0xef, 0xc7, 0x78, 0xa0, 0xb3, 0xc9, 0x12, 0x11, 0x2f, 0x7a, 0xeb, 0x22, 0x17, 0x39, 0xe9,
	0x6a, 0xc4, 0xa3, 0x15, 0x3e, 0x30, 0xb7, 0x09, 0x66, 0xf0, 0xb0, 0x16, 0x5b, 0xf7, 0x0c, 0x1a,
	0x13, 0x16, 0xbd, 0x43, 0x41, 0x08, 0xd4, 0x63, 0x26, 0x98, 0x63, 0x9c, 0x1b, 0x17, 0x1d, 0xaa,
	0xce, 0xee, 0xbf, 0x06, 0xb4, 0xaf, 0x93, 0x3f, 0x31, 0xbe, 0x41, 0x16, 0x63, 0x41, 0x7e, 0x84,
	0xf6, 0x1d, 0x72, 0xce, 0x96, 0x38, 0xdb, 0xae, 0x51, 0x99, 0x9e, 0x5e, 0xbd, 0xea, 0x55, 0x62,
	0xf7, 0x4a, 0x16, 0xb4, 0x6c, 0x2e, 0xbd, 0xaf, 0xd3, 0xfc, 0xd1, 0xcb, 0x33, 0x51, 0xe4, 0xa9,
	0x73, 0x72, 0xd4, 0xbb, 0x64, 0x41, 0xcb, 0xe6, 0xe4, 0x6b, 0xe8, 0xea, 0x60, 0x43, 0xcc, 0x96,
	0x62, 0xe5, 0xd4, 0xce, 0x8d, 0x0b, 0x93, 0x56, 0x49, 0xf7, 0xef, 0x1a, 0x34, 0xbd, 0x3c, 0xcb,
	0x30, 0x12, 0xc4, 0x81, 0xe6, 0x3d, 0x16, 0x3c, 0xc9, 0x33, 0xa5, 0xd4, 0xa4, 0x7b, 0x48, 0x5c,
	0xe8, 0x84, 0x19, 0xc7, 0x68, 0x53, 0xe0, 0x75, 0xca, 0x96, 0x4a, 0x4a, 0x8b, 0x56, 0x38, 0xf2,
	0x0a, 0x5a, 0x5e, 0x9a, 0x60, 0x26, 0x42, 0x5f, 0xa5, 0xb2, 0xe8, 0x13, 0x26, 0x67, 0x60, 0xdd,
	0x22, 0xae, 0xfb, 0x69, 0xf2, 0x07, 0x3a, 0x75, 0x15, 0xfb, 0x40, 0x48, 0xa5, 0x5e, 0x8a, 0x2c,
	0x9b, 0x22, 0xe7, 0x2a, 0xbc, 0xa9, 0xc2, 0x57, 0x49, 0xa9, 0x4e, 0x9e, 0x6f, 0x71, 0xeb, 0x34,
	0x76, 0xea, 0x34, 0x94, 0x99, 0xe7, 0x1c, 0x8b, 0x8c, 0x3d, 0xa0, 0xd3, 0xdc, 0x65, 0xde, 0x63,
	0xf9, 0x6d, 0xc2, 0x38, 0x7f, 0xcc, 0x8b, 0xd8, 0x69, 0xa9, 0x49, 0x3d, 0x61, 0x99, 0x77, 0xc0,
	0x44, 0xb4, 0xf2, 0x37, 0x05, 0x13, 0xb2, 0x6a, 0x6b, 0xd7, 0xa1, 0x0a, 0x49, 0x7a, 0x40, 0x14,
	0x31, 0xd8, 0x0a, 0x9c, 0xad, 0x0a, 0xe4, 0xab, 0x3c, 0x8d, 0x1d, 0x50, 0xa6, 0x47, 0xbe, 0x90,
	0xd7, 0xf0, 0xa9, 0x62, 0xbd, 0x7c, 0x93, 0x89, 0x83, 0x43, 0x5b, 0x39, 0x1c, 0xfb, 0xe4, 0x2e,
	0x80, 0xe8, 0x11, 0xf4, 0xa3, 0x77, 0x59, 0xfe, 0x98, 0x62, 0xbc, 0x44, 0xf2, 0x15, 0x00, 0x45,
	0xb1, 0x29, 0x32, 0x2f, 0x8f, 0x51, 0x0f, 0xa4, 0xc4, 0x90, 0x97, 0x60, 0x06, 0xeb, 0x3c, 0x5a,
	0xa9, 0x61, 0x98, 0x74, 0x07, 0xc8, 0xe7, 0xd0, 0x90, 0xb1, 0xf4, 0x0c, 0x4c, 0xaa, 0x91, 0xdb,
	0x85, 0xf6, 0x24, 0xc9, 0x96, 0x14, 0x7f, 0xdf, 0x20, 0x17, 0xee, 0x25, 0x80, 0x9f, 0xf0, 0x48,
	0x0f, 0xfe, 0x0c, 0x2c, 0xbd, 0x15, 0xa1, 0xaf, 0x33, 0x1d, 0x08, 0x97, 0xc2, 0xe9, 0x64, 0xb3,
	0x48, 0x13, 0xbe, 0xd2, 0x9c, 0x4c, 0x3d, 0xcb, 0xd7, 0x49, 0xa4, 0x6c, 0x2d, 0xba, 0x03, 0x72,
	0x40, 0x13, 0xb6, 0x4d, 0x73, 0x16, 0x2b, 0x49, 0x1d, 0xba, 0x87, 0xc4, 0x86, 0xda, 0x4c, 0xa4,
	0x7a, 0x2b, 0xe4, 0xd1, 0xfd, 0xc7, 0x80, 0xa6, 0x0e, 0xfa, 0xe1, 0xec, 0x72, 0xf5, 0x7c, 0x94,
	0x6b, 0x52, 0x6c, 0xef, 0x64, 0x23, 0x76, 0xd5, 0x56, 0x38, 0xf2, 0x1d, 0xb4, 0xb4, 0x03, 0x77,
	0x6a, 0xe7, 0xb5, 0x8b, 0xf6, 0xd5, 0x97, 0xcf, 0x6e, 0x49, 0xb5, 0x00, 0xfa, 0x64, 0xee, 0x7e,
	0x0b, 0x1d, 0x8a, 0x29, 0xdb, 0xea, 0xc6, 0xbc, 0xa7, 0x34, 0x02, 0xf5, 0x21, 0xe3, 0x42, 0x25,
	0xb7, 0xa8, 0x3a, 0xbb, 0x2b, 0x30, 0x95, 0xe7, 0x47, 0xf4, 0xf7, 0xa1, 0x5b, 0x94, 0x12, 0x70,
	0xe7, 0x44, 0x09, 0xfc, 0xe2, 0x99, 0xc0, 0xb2, 0x08, 0x5a, 0xf5, 0x70, 0x7f, 0x83, 0xce, 0x74,
	0xb3, 0xe0, 0x51, 0x91, 0xac, 0x85, 0xbe, 0x8d, 0x95, 0x96, 0x18, 0x47, 0x5a, 0xf2, 0x12, 0x4c,
	0x5f, 0x06, 0xd9, 0x6f, 0x87, 0x02, 0x87, 0xea, 0x6a, 0xa5, 0xea, 0xdc, 0x14, 0x2c, 0x1d, 0x7f,
	0x81, 0x1f, 0xaf, 0xa6, 0x2c, 0xe5, 0x7d, 0xd5, 0x94, 0x6d, 0x68, 0xd5, 0xc3, 0xcd, 0xa0, 0x3d,
	0xcf, 0xf8, 0xff, 0x97, 0xef, 0x06, 0x4e, 0xf5, 0x2f, 0x71, 0xbf, 0xbe, 0x1f, 0x4e, 0xe9, 0x40,
	0x53, 0x83, 0xfd, 0x1a, 0x6b, 0x78, 0xf9, 0x6b, 0xe5, 0x7f, 0x4c, 0x5a, 0x50, 0x1f, 0x8d, 0x47,
	0x81, 0xfd, 0x82, 0x7c, 0x02, 0xed, 0xbe, 0x77, 0x3b, 0x1a, 0xff, 0x3c, 0x0c, 0xfc, 0x37, 0x81,
	0x6d, 0x10, 0x80, 0xc6, 0x68, 0x3c, 0x0b, 0xaf, 0xdf, 0xda, 0x27, 0xa4, 0x0d, 0x4d, 0x1a, 0x78,
	0x41, 0x78, 0x1f, 0xd8, 0xb5, 0x27, 0x30, 0x99, 0xd9, 0x75, 0xd2, 0x81, 0x96, 0x37, 0xbe, 0x9b,
	0x0c, 0x83, 0x59, 0x60, 0x9b, 0x97, 0x7f, 0x55, 0xde, 0x0a, 0xd2, 0x05, 0x8b, 0x06, 0x74, 0x1a,
	0xd0, 0xfb, 0xc0, 0xb7, 0x5f, 0x48, 0x47, 0x6f, 0x3c, 0x1a, 0x05, 0xde, 0xcc, 0x36, 0x24, 0x98,
	0xcc, 0x07, 0xc3, 0x70, 0x7a, 0x63, 0x9f, 0x10, 0x0b, 0x4c, 0x1a, 0x0c, 0xfb, 0x6f, 0xed, 0x9a,
	0xf4, 0x99, 0xce, 0x07, 0x53, 0x8f, 0x86, 0x83, 0xc0, 0xae, 0x4b, 0x59, 0xf3, 0xd1, 0x81, 0x30,
	0x95, 0x5f, 0x38, 0x7a, 0x43, 0x83, 0x9f, 0xec, 0x06, 0x39, 0x05, 0xf0, 0xc3, 0xe9, 0x3e, 0x68,
	0xf3, 0xca, 0x87, 0xc6, 0x5c, 0x35, 0x95, 0x7c, 0x0f, 0x8d, 0xa9, 0x28, 0x90, 0x3d, 0x90, 0xcf,
	0x9e, 0x5f, 0x23, 0xf5, 0xf4, 0xbd, 0x3a, 0x4e, 0x5f, 0x18, 0xaf, 0x8d, 0x01, 0xfc, 0xd2, 0xea,
	0xfd, 0xb0, 0xa3, 0x17, 0x0d, 0xf5, 0x94, 0x7e, 0xf3, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x88,
	0xb8, 0x3c, 0xf1, 0x5a, 0x07, 0x00, 0x00,
}
